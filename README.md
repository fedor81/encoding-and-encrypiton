# Encoding and Encryption

## Содержание

- [Эффективное кодирование](#эффективное-кодирование)
- [Архиватор на основе алгоритма Хаффмана](#архиватор-файлов-по-алгоритму-хаффмана)
- [Помехоустойчивое кодирование](#помехоустойчивое-кодирование)

## Эффективное кодирование

Сравнение способов кодирования Шеннона-Фано и Хаффмана!

- **Построение кодов** по вектору вероятностей.
- **Вычисление**: средней длинны кодов, коэффициентов статистического сжатия и относительной эффективности.

### Построение кодов Шеннона-Фано

1. Вектор вероятностей сортируется
2. Каждый раз он делится на две примерно равные по сумме части, кодам первой приписывается `0`, кодам второй - `1`.

### Построение кодов Хаффмана

1. Записываем все вероятности в бинарную кучу `BinaryHeap`.
2. Извлекаем две самые маленькие и объединяем в узел дерева `HuffmanTree::Node` с двумя листьями `HuffmanTree::Leaf`. Кладем узел обратно в кучу, вероятность Node будет равна сумме листьев Leaf.
3. Повторяем пока в куче не останется один корневой элемент. Извлекаем из дерева коды, считая, что переход по левой ветке `0`, по правой - `1`.

### Binary

```sh
cargo run --bin efficient_encoding
```

Пример работы:

```text
Enter a vector of probabilities of characters appearing separated by a whitespace:
0.170 0.168 0.166 0.140 0.118 0.110 0.083 0.045
```

Полученные данные:

| Name         | Probabilities                                       | Codes                                   | Mean length | Relative efficiency ratio | Statistical compression ratio |
| ------------ | --------------------------------------------------- | --------------------------------------- | ----------- | ------------------------- | ----------------------------- |
| Shannon-Fano | 0.17, 0.168, 0.166, 0.14, 0.118, 0.11, 0.083, 0.045 | 00, 010, 011, 100, 101, 110, 1110, 1111 | 2.958       | 0.9829476741267483        | 1.0141987829614605            |
| Huffman      | 0.17, 0.168, 0.166, 0.14, 0.118, 0.11, 0.083, 0.045 | 00, 111, 110, 101, 011, 010, 1001, 1000 | 2.958       | 0.9829476741267483        | 1.0141987829614605            |

## Архиватор файлов по алгоритму Хаффмана

### Принцип архивации

1. Читается файл, строится таблица частот встречающихся байтов `FrequencyMap`.
2. На основе частот строится дерево хаффмана `HuffmanTree`, как говорилось в [эффективном кодировании](#построение-кодов-хаффмана), и извлечение кодов в словарь `HashMap<u8, String>`.
3. Происходит второй проход по файлу и кодирование. Результат записывается в строку из нулей и единиц, которая переводится в массив байт `Vec<u8>`.
4. Словарь кодовых слов переводится в массив байт, где каждая запись представляется как: слово(1 байт), длина кода(1 байт), кодовое слово(2 байта).
5. Создается новый файл, в который записывается: размер состояния, само состояние(словарь кодовых слов), затем закодированный файл.

### Разархивация

1. Из файла читается размер состояния, затем само состояние.
2. Состояние переводится обратно в словарь `HashMap<u8, String>`, по кодовым словам строится дерево Хаффмана `HuffmanTree`.
3. Читается закодированная часть файла `Vec<u8>` и представляется как строка `String`.
4. Происходит декодирование, так как ни один код не является началом другого.
5. Получаем разархивированный файл.

### Сравнение эффективности алгоритма на разных фалах

| Содержание файла                                          | Размер до кодирования | Размер после кодирования | Процент от исходного файла |
| --------------------------------------------------------- | --------------------- | ------------------------ | -------------------------- |
| aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa        | 50 байт               | 22 байт                  | 44%                        |
| abababababababababababaababababaabababa                   | 39 байт               | 31 байт                  | 79.49%                     |
| 1234567890-=qwertyuiop[]asdfghjkl;'\zxcvbnm,./            | 46 байт               | 235 байт                 | 510.87%                    |
| [huffman_tree.rs](./archiver/src/huffman/huffman_tree.rs) | 12.11 Кбайт           | 7.14 Кбайт               | 58.94%                     |

Из за необходимости хранить словарь кодовых слов, алгоритм Хаффмана может быть неэффективным на небольших файлах.

### Binary

Для работы нужно будет указать пути к входному и выходному файлам.

Кодировщик:

```sh
cargo run --bin huffman_encoder
```

Декодировщик:

```sh
cargo run --bin huffman_decoder
```

### Используемая литература

- [Алгоритм Хаффмана на пальцах](https://habr.com/ru/articles/144200/)

## Помехоустойчивое кодирование

Программная реализация помехоустойчивого кода Рида-Соломона: механизма исправления и обнаружения ошибок

### Принцип работы

#### Поле Галуа GF256

- Содержит 256 элементов.
- Примитивный элемент поля — это элемент, который порождает мультипликативную группу, то есть при возведении его в степени от 1 до 255 (исключая 0) можно получить все ненулевые элементы этого поля.
- Операции сложения и вычитания определена как x XOR y.
- Умножение производится как обычное, но со взятием по модулю, который должен быть неприводимым многочленом, например, $x⁸ + x⁴ + x³ + x² + 1 =$ 0x11D.
- Но каждый раз вычислять результат умножения затратно, поэтому можно сделать это заранее. Воспользуясь правилом $a=x^n$, $b=x^m$, то $a*b=x^{n+m}$, где $a$ – это примитивный элемент поля

  - Подсчитаем таблицу степеней $exp[i] = x^i$
  - Подсчитаем таблицу логарифмов $x^{log[a]} = a$
  - Получаем $a * b = exp[\log(a) + \log(b) \% 255]$

  Применим это же правило при делении и возведении в степень.

![Поле Галуа](./.github/GF256.png)

#### Кодирование

1. Кодировщик строит порождающий многочлен для указанного количества контрольных символов следующим образом: $g(x) = (x + a^0)(x + a^1)...(x + a^{control\_count-1})$.
2. На вход поступает массив байт, что представляет собой многочлен, где элемент $a$ под индексом $i$ является коэффициентом при $x^i$.
3. Сдвигает данные на $control\_count$ позиций, освобождая место для контрольных символов и получая увеличенный на $x^{control\_count}$ полином.
4. Делит полученный полином на порождающий многочлен $g(x)$. Остаток от деления - и есть контрольные символы.
5. Записывает их в начало полинома.

#### Декодирование

1. От поступившего сообщения вычисляет синдромы. Синдром $i$ – это результат подстановки в многочлен примитивного элемента $a^i$. Если все синдромы нулевые, то сообщение не искажено.

2. Ищем локатор ошибок методом *Берлекэмпа-Месси*:

   - Изначально устанавливаем локатор $C(x) = 1$, степень локатора $L = 0$, номер итерации с последней корректировки $m = 0$.
   - На каждом шаге $i$ вычисляем расхождение $d = Sn + C₁ * S_{n-1} + C₂ * S_{n-2} + ... + C_L * S_{n-L}$, где $S_i$ – это синдром, а $C_i$ – это коэффициент локатора ошибок.
   - Если расхождение $d = 0$, то просто увеличиваем $m + 1$, начиная цикл сначала.
   - Если расхождение не равно нулю $d \ne 0$, то корректируем локатор $C(x) = C(x) - (d/b)*B(x)·x^m$, где $B(x)$ – предыдущее значение локатора на момент последнего корректирования, $b$ - копия последнего расхождения $d$.
   - Если степень локатора меньше либо равна шагу $L <= i$, то нужно обновить $B(x)$ и $b$.
   - Повторяем столько раз, сколько у нас имеется синдромов.

3. По локатору ошибок находятся позиции ошибок методом *Ченя*.

   Для всех ненулевых элементов, которые генерируются в порядке $1, a_1, а_2, ...  a_i$ проверяется условие $C(a^{-1}) = 0$.

   Так как $C(x) = (1+xX_1)(1+xX_2)...(1+xXi)$, где $X_1, X_2, X_i$ – локаторы ошибок, то $1+xX_i$ обращается в ноль при $x=X_i^{-1} : X_i * X_i^{-1} = 1, 1+1 =0$.

   Если элемент $a_i$ обращает локатор в $0$, то на месте $i$ находится ошибка.

4. Для нахождения значений ошибок вычисляется $W(x) = C(x)*S(x)$, коэффициенты старшие чем $n-k$ должны быть обнулены.

   Вычисляем производную локатора $C'(x)$ следующим образом: для четных степеней производная равна $0$, для нечетных – как обычно.

   Далее вычисляются значения ошибок $Y_i = W(x_i^{-1}) / C'(x_i^{-1})$ – где $x_i = a^{pos\_i}$ – это примитивный элемент в степени равной позиции ошибки.

5. Из сообщения на найденных позициях $i$ вычитаются значения ошибок $Y_i$, проверяются синдромы, они все должны быть равны нулю $S_i = 0$, и получается результат.

### Binary

```sh
cargo run --bin=reed_solomon  -- --controls=20 encode "Hello World" --output-format=bytes

243 36 192 41 21 204 168 6 115 241 25 244 46 11 250 86 45 134 128 164 72 101 108 108 111 32 87 111 114 108 100
```

Может исправить до `control_count / 2` ошибок:

```sh
cargo run --bin=reed_solomon  -- decode cc57946b60ce57fedc9f48656c6c6f20576f700000 # Пять ошибок в конце

Hello World
```

### Используемая литература

- [Детальный обзор полей Галуа](https://habr.com/ru/articles/916740/)
- [Коды Рида-Соломона с точки зрения обывателя](https://asvk.cs.msu.ru/wp-content/uploads/2023/04/Kody-Rida-Solomona-1.pdf)
- [Алгоритм Берлекэмпа — Мэсси](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%B5%D1%80%D0%BB%D0%B5%D0%BA%D1%8D%D0%BC%D0%BF%D0%B0_%E2%80%94_%D0%9C%D1%8D%D1%81%D1%81%D0%B8)
- [Метод Ченя и исправление ошибок](https://studfile.net/preview/7328865/page:23/)