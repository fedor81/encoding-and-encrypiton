# Помехоустойчивое кодирование

Программная реализация помехоустойчивого кода Рида-Соломона: механизма исправления и обнаружения ошибок

## Принцип работы

### Поле Галуа GF256

- Содержит 256 элементов.
- Примитивный элемент поля — это элемент, который порождает мультипликативную группу, то есть при возведении его в степени от 1 до 255 (исключая 0) можно получить все ненулевые элементы этого поля.
- Операции сложения и вычитания определена как x XOR y.
- Умножение производится как обычное, но со взятием по модулю, который должен быть неприводимым многочленом, например, $x⁸ + x⁴ + x³ + x² + 1 =$ 0x11D.
- Но каждый раз вычислять результат умножения затратно, поэтому можно сделать это заранее. Воспользуясь правилом $a=x^n$, $b=x^m$, то $a*b=x^{n+m}$, где $a$ – это примитивный элемент поля

  - Подсчитаем таблицу степеней $exp[i] = x^i$
  - Подсчитаем таблицу логарифмов $x^{log[a]} = a$
  - Получаем $a * b = exp[\log(a) + \log(b) \% 255]$

  Применим это же правило при делении и возведении в степень.

![Поле Галуа](./.github/GF256.png)

### Кодирование

1. Кодировщик строит порождающий многочлен для указанного количества контрольных символов следующим образом: $g(x) = (x + a^0)(x + a^1)...(x + a^{control\_count-1})$.
2. На вход поступает массив байт, что представляет собой многочлен, где элемент $a$ под индексом $i$ является коэффициентом при $x^i$.
3. Сдвигает данные на $control\_count$ позиций, освобождая место для контрольных символов и получая увеличенный на $x^{control\_count}$ полином.
4. Делит полученный полином на порождающий многочлен $g(x)$. Остаток от деления - и есть контрольные символы.
5. Записывает их в начало полинома.

### Декодирование

1. От поступившего сообщения вычисляет синдромы. Синдром $i$ – это результат подстановки в многочлен примитивного элемента $a^i$. Если все синдромы нулевые, то сообщение не искажено.

2. Ищем локатор ошибок методом _Берлекэмпа-Месси_:

   - Изначально устанавливаем локатор $C(x) = 1$, степень локатора $L = 0$, номер итерации с последней корректировки $m = 0$.
   - На каждом шаге $i$ вычисляем расхождение $d = Sn + C₁ * S_{n-1} + C₂ * S_{n-2} + ... + C_L * S_{n-L}$, где $S_i$ – это синдром, а $C_i$ – это коэффициент локатора ошибок.
   - Если расхождение $d = 0$, то просто увеличиваем $m + 1$, начиная цикл сначала.
   - Если расхождение не равно нулю $d \ne 0$, то корректируем локатор $C(x) = C(x) - (d/b)*B(x)·x^m$, где $B(x)$ – предыдущее значение локатора на момент последнего корректирования, $b$ - копия последнего расхождения $d$.
   - Если степень локатора меньше либо равна шагу $L <= i$, то нужно обновить $B(x)$ и $b$.
   - Повторяем столько раз, сколько у нас имеется синдромов.

3. По локатору ошибок находятся позиции ошибок методом _Ченя_.

   Для всех ненулевых элементов, которые генерируются в порядке $1, a_1, а_2, ...  a_i$ проверяется условие $C(a^{-1}) = 0$.

   Так как $C(x) = (1+xX_1)(1+xX_2)...(1+xXi)$, где $X_1, X_2, X_i$ – локаторы ошибок, то $1+xX_i$ обращается в ноль при $x=X_i^{-1} : X_i * X_i^{-1} = 1, 1+1 =0$.

   Если элемент $a_i$ обращает локатор в $0$, то на месте $i$ находится ошибка.

4. Для нахождения значений ошибок вычисляется $W(x) = C(x)*S(x)$, коэффициенты старшие чем $n-k$ должны быть обнулены.

   Вычисляем производную локатора $C'(x)$ следующим образом: для четных степеней производная равна $0$, для нечетных – как обычно.

   Далее вычисляются значения ошибок $Y_i = W(x_i^{-1}) / C'(x_i^{-1})$ – где $x_i = a^{pos\_i}$ – это примитивный элемент в степени равной позиции ошибки.

5. Из сообщения на найденных позициях $i$ вычитаются значения ошибок $Y_i$, проверяются синдромы, они все должны быть равны нулю $S_i = 0$, и получается результат.

## Binary

Способ использования показан в [reed_solomon_bin](../reed_solomon_bin/README.md#использование)

## Используемая литература

- [Детальный обзор полей Галуа](https://habr.com/ru/articles/916740/)
- [Коды Рида-Соломона с точки зрения обывателя](https://asvk.cs.msu.ru/wp-content/uploads/2023/04/Kody-Rida-Solomona-1.pdf)
- [Алгоритм Берлекэмпа — Мэсси](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%B5%D1%80%D0%BB%D0%B5%D0%BA%D1%8D%D0%BC%D0%BF%D0%B0_%E2%80%94_%D0%9C%D1%8D%D1%81%D1%81%D0%B8)
- [Метод Ченя и исправление ошибок](https://studfile.net/preview/7328865/page:23/)
