use anyhow::Result;

use super::{CorrectionLevel, Version};

/// Obtains an object from a hard-coded table.
///
/// The table must be a 40×4 array. The outer array represents the content for each version.
/// The inner array represents the content in each error correction level, in the order [L, M, Q, H].
pub fn fetch<T>(version: Version, corr_level: CorrectionLevel, table: &[[T; 4]; 40]) -> Result<T>
where
    T: PartialEq + Default + Copy,
{
    if 1 <= version.num() && version.num() <= 40 {
        return Ok(table[(version.num() - 1) as usize][corr_level as usize]);
    }
    anyhow::bail!("Invalid version: {}. Version must be in range [1, 40]", version.num())
}

/// This table is copied from https://github.com/kennytm/qrcode-rust
pub const DATA_LENGTHS: [[u16; 4]; 40] = [
    [152, 128, 104, 72],
    [272, 224, 176, 128],
    [440, 352, 272, 208],
    [640, 512, 384, 288],
    [864, 688, 496, 368],
    [1088, 864, 608, 480],
    [1248, 992, 704, 528],
    [1552, 1232, 880, 688],
    [1856, 1456, 1056, 800],
    [2192, 1728, 1232, 976],
    [2592, 2032, 1440, 1120],
    [2960, 2320, 1648, 1264],
    [3424, 2672, 1952, 1440],
    [3688, 2920, 2088, 1576],
    [4184, 3320, 2360, 1784],
    [4712, 3624, 2600, 2024],
    [5176, 4056, 2936, 2264],
    [5768, 4504, 3176, 2504],
    [6360, 5016, 3560, 2728],
    [6888, 5352, 3880, 3080],
    [7456, 5712, 4096, 3248],
    [8048, 6256, 4544, 3536],
    [8752, 6880, 4912, 3712],
    [9392, 7312, 5312, 4112],
    [10208, 8000, 5744, 4304],
    [10960, 8496, 6032, 4768],
    [11744, 9024, 6464, 5024],
    [12248, 9544, 6968, 5288],
    [13048, 10136, 7288, 5608],
    [13880, 10984, 7880, 5960],
    [14744, 11640, 8264, 6344],
    [15640, 12328, 8920, 6760],
    [16568, 13048, 9368, 7208],
    [17528, 13800, 9848, 7688],
    [18448, 14496, 10288, 7888],
    [19472, 15312, 10832, 8432],
    [20528, 15936, 11408, 8768],
    [21616, 16816, 12016, 9136],
    [22496, 17728, 12656, 9776],
    [23648, 18672, 13328, 10208],
];

/// `EC_BYTES_PER_BLOCK` provides the number of codewords (bytes) used for error
/// correction per block in each version.
///
/// This table is copied from https://github.com/kennytm/qrcode-rust
pub const EC_BYTES_PER_BLOCK: [[u8; 4]; 40] = [
    [7, 10, 13, 17],  // 1
    [10, 16, 22, 28], // 2
    [15, 26, 18, 22], // 3
    [20, 18, 26, 16], // 4
    [26, 24, 18, 22], // 5
    [18, 16, 24, 28], // 6
    [20, 18, 18, 26], // 7
    [24, 22, 22, 26], // 8
    [30, 22, 20, 24], // 9
    [18, 26, 24, 28], // 10
    [20, 30, 28, 24], // 11
    [24, 22, 26, 28], // 12
    [26, 22, 24, 22], // 13
    [30, 24, 20, 24], // 14
    [22, 24, 30, 24], // 15
    [24, 28, 24, 30], // 16
    [28, 28, 28, 28], // 17
    [30, 26, 28, 28], // 18
    [28, 26, 26, 26], // 19
    [28, 26, 30, 28], // 20
    [28, 26, 28, 30], // 21
    [28, 28, 30, 24], // 22
    [30, 28, 30, 30], // 23
    [30, 28, 30, 30], // 24
    [26, 28, 30, 30], // 25
    [28, 28, 28, 30], // 26
    [30, 28, 30, 30], // 27
    [30, 28, 30, 30], // 28
    [30, 28, 30, 30], // 29
    [30, 28, 30, 30], // 30
    [30, 28, 30, 30], // 31
    [30, 28, 30, 30], // 32
    [30, 28, 30, 30], // 33
    [30, 28, 30, 30], // 34
    [30, 28, 30, 30], // 35
    [30, 28, 30, 30], // 36
    [30, 28, 30, 30], // 37
    [30, 28, 30, 30], // 38
    [30, 28, 30, 30], // 39
    [30, 28, 30, 30], // 40
];

/// `DATA_BYTES_PER_BLOCK` provides the number of codewords (bytes) used for
/// real data per block in each version.
///
/// This table is copied from https://github.com/kennytm/qrcode-rust
///
/// Every entry is a 4-tuple. Take `DATA_BYTES_PER_BLOCK[39][3] == (15, 20, 16, 61)`
/// as an example, this means in version 40 with correction level H, there are
/// 20 blocks with 15 bytes in size, and 61 blocks with 16 bytes in size.
pub const DATA_BYTES_PER_BLOCK: [[(u8, u8, u8, u8); 4]; 40] = [
    // Normal versions.
    [(19, 1, 0, 0), (16, 1, 0, 0), (13, 1, 0, 0), (9, 1, 0, 0)], // 1
    [(34, 1, 0, 0), (28, 1, 0, 0), (22, 1, 0, 0), (16, 1, 0, 0)], // 2
    [(55, 1, 0, 0), (44, 1, 0, 0), (17, 2, 0, 0), (13, 2, 0, 0)], // 3
    [(80, 1, 0, 0), (32, 2, 0, 0), (24, 2, 0, 0), (9, 4, 0, 0)], // 4
    [(108, 1, 0, 0), (43, 2, 0, 0), (15, 2, 16, 2), (11, 2, 12, 2)], // 5
    [(68, 2, 0, 0), (27, 4, 0, 0), (19, 4, 0, 0), (15, 4, 0, 0)], // 6
    [(78, 2, 0, 0), (31, 4, 0, 0), (14, 2, 15, 4), (13, 4, 14, 1)], // 7
    [(97, 2, 0, 0), (38, 2, 39, 2), (18, 4, 19, 2), (14, 4, 15, 2)], // 8
    [(116, 2, 0, 0), (36, 3, 37, 2), (16, 4, 17, 4), (12, 4, 13, 4)], // 9
    [(68, 2, 69, 2), (43, 4, 44, 1), (19, 6, 20, 2), (15, 6, 16, 2)], // 10
    [(81, 4, 0, 0), (50, 1, 51, 4), (22, 4, 23, 4), (12, 3, 13, 8)], // 11
    [(92, 2, 93, 2), (36, 6, 37, 2), (20, 4, 21, 6), (14, 7, 15, 4)], // 12
    [(107, 4, 0, 0), (37, 8, 38, 1), (20, 8, 21, 4), (11, 12, 12, 4)], // 13
    [(115, 3, 116, 1), (40, 4, 41, 5), (16, 11, 17, 5), (12, 11, 13, 5)], // 14
    [(87, 5, 88, 1), (41, 5, 42, 5), (24, 5, 25, 7), (12, 11, 13, 7)], // 15
    [(98, 5, 99, 1), (45, 7, 46, 3), (19, 15, 20, 2), (15, 3, 16, 13)], // 16
    [(107, 1, 108, 5), (46, 10, 47, 1), (22, 1, 23, 15), (14, 2, 15, 17)], // 17
    [(120, 5, 121, 1), (43, 9, 44, 4), (22, 17, 23, 1), (14, 2, 15, 19)], // 18
    [(113, 3, 114, 4), (44, 3, 45, 11), (21, 17, 22, 4), (13, 9, 14, 16)], // 19
    [(107, 3, 108, 5), (41, 3, 42, 13), (24, 15, 25, 5), (15, 15, 16, 10)], // 20
    [(116, 4, 117, 4), (42, 17, 0, 0), (22, 17, 23, 6), (16, 19, 17, 6)], // 21
    [(111, 2, 112, 7), (46, 17, 0, 0), (24, 7, 25, 16), (13, 34, 0, 0)], // 22
    [(121, 4, 122, 5), (47, 4, 48, 14), (24, 11, 25, 14), (15, 16, 16, 14)], // 23
    [(117, 6, 118, 4), (45, 6, 46, 14), (24, 11, 25, 16), (16, 30, 17, 2)], // 24
    [(106, 8, 107, 4), (47, 8, 48, 13), (24, 7, 25, 22), (15, 22, 16, 13)], // 25
    [(114, 10, 115, 2), (46, 19, 47, 4), (22, 28, 23, 6), (16, 33, 17, 4)], // 26
    [(122, 8, 123, 4), (45, 22, 46, 3), (23, 8, 24, 26), (15, 12, 16, 28)], // 27
    [(117, 3, 118, 10), (45, 3, 46, 23), (24, 4, 25, 31), (15, 11, 16, 31)], // 28
    [(116, 7, 117, 7), (45, 21, 46, 7), (23, 1, 24, 37), (15, 19, 16, 26)], // 29
    [(115, 5, 116, 10), (47, 19, 48, 10), (24, 15, 25, 25), (15, 23, 16, 25)], // 30
    [(115, 13, 116, 3), (46, 2, 47, 29), (24, 42, 25, 1), (15, 23, 16, 28)], // 31
    [(115, 17, 0, 0), (46, 10, 47, 23), (24, 10, 25, 35), (15, 19, 16, 35)], // 32
    [(115, 17, 116, 1), (46, 14, 47, 21), (24, 29, 25, 19), (15, 11, 16, 46)], // 33
    [(115, 13, 116, 6), (46, 14, 47, 23), (24, 44, 25, 7), (16, 59, 17, 1)], // 34
    [(121, 12, 122, 7), (47, 12, 48, 26), (24, 39, 25, 14), (15, 22, 16, 41)], // 35
    [(121, 6, 122, 14), (47, 6, 48, 34), (24, 46, 25, 10), (15, 2, 16, 64)], // 36
    [(122, 17, 123, 4), (46, 29, 47, 14), (24, 49, 25, 10), (15, 24, 16, 46)], // 37
    [(122, 4, 123, 18), (46, 13, 47, 32), (24, 48, 25, 14), (15, 42, 16, 32)], // 38
    [(117, 20, 118, 4), (47, 40, 48, 7), (24, 43, 25, 22), (15, 10, 16, 67)], // 39
    [(118, 19, 119, 6), (47, 18, 48, 31), (24, 34, 25, 34), (15, 20, 16, 61)], // 40
];

/// `ALIGNMENT_PATTERN_POSITIONS` describes the x- and y-coordinates of the
/// center of the alignment patterns. Since the QR code is symmetric, only one
/// coordinate is needed.
///
/// To this table copied from https://github.com/kennytm/qrcode-rust positions
/// for codes from 1 to 6 have been added.
pub const ALIGNMENT_PATTERN_POSITIONS: [&[u8]; 40] = [
    &[],
    &[18],
    &[22],
    &[26],
    &[30],
    &[34],
    &[6, 22, 38],
    &[6, 24, 42],
    &[6, 26, 46],
    &[6, 28, 50],
    &[6, 30, 54],
    &[6, 32, 58],
    &[6, 34, 62],
    &[6, 26, 46, 66],
    &[6, 26, 48, 70],
    &[6, 26, 50, 74],
    &[6, 30, 54, 78],
    &[6, 30, 56, 82],
    &[6, 30, 58, 86],
    &[6, 34, 62, 90],
    &[6, 28, 50, 72, 94],
    &[6, 26, 50, 74, 98],
    &[6, 30, 54, 78, 102],
    &[6, 28, 54, 80, 106],
    &[6, 32, 58, 84, 110],
    &[6, 30, 58, 86, 114],
    &[6, 34, 62, 90, 118],
    &[6, 26, 50, 74, 98, 122],
    &[6, 30, 54, 78, 102, 126],
    &[6, 26, 52, 78, 104, 130],
    &[6, 30, 56, 82, 108, 134],
    &[6, 34, 60, 86, 112, 138],
    &[6, 30, 58, 86, 114, 142],
    &[6, 34, 62, 90, 118, 146],
    &[6, 30, 54, 78, 102, 126, 150],
    &[6, 24, 50, 76, 102, 128, 154],
    &[6, 28, 54, 80, 106, 132, 158],
    &[6, 32, 58, 84, 110, 136, 162],
    &[6, 26, 54, 82, 110, 138, 166],
    &[6, 30, 58, 86, 114, 142, 170],
];

/// Переводит число в вектор бит, указанного размера. Первые если в числе бит меньше чем длина вектора,
/// то они принимаются нулями.
fn to_bit_array(value: u32, size: usize) -> Vec<bool> {
    let mut bits = vec![false; size];
    for i in 0..18 {
        bits[17 - i] = (value >> i) & 1 == 1;
    }
    bits
}

/// This table is copied from https://habr.com/ru/articles/172525/
pub const VERSION_INFO: [u32; 34] = [
    0b000010_011110_100110,
    0b010001_011100_111000,
    0b110111_011000_000100,
    0b101001_111110_000000,
    0b001111_111010_111100,
    0b001101_100100_011010,
    0b101011_100000_100110,
    0b110101_000110_100010,
    0b010011_000010_011110,
    0b011100_010001_011100,
    0b111010_010101_100000,
    0b100100_110011_100100,
    0b000010_110111_011000,
    0b000000_101001_111110,
    0b100110_101101_000010,
    0b111000_001011_000110,
    0b011110_001111_111010,
    0b001101_001101_100100,
    0b101011_001001_011000,
    0b110101_101111_011100,
    0b010011_101011_100000,
    0b010001_110101_000110,
    0b110111_110001_111010,
    0b101001_010111_111110,
    0b001111_010011_000010,
    0b101000_011000_101101,
    0b001110_011100_010001,
    0b010000_111010_010101,
    0b110110_111110_101001,
    0b110100_100000_001111,
    0b010010_100100_110011,
    0b001100_000010_110111,
    0b101010_000110_001011,
    0b111001_000100_010101,
];

/// | Номер маски | Маска                        |
/// | ----------- | ---------------------------- |
/// | 0           | (X+Y) % 2                    |
/// | 1           | Y % 2                        |
/// | 2           | X % 3                        |
/// | 3           | (X + Y) % 3                  |
/// | 4           | (X/3 + Y/2) % 2              |
/// | 5           | (X*Y) % 2 + (X*Y) % 3        |
/// | 6           | ((X*Y) % 2 + (X*Y) % 3) % 2  |
/// | 7           | ((X\*Y) % 3 + (X+Y) % 2) % 2 |
const MASKS: [u16; 32] = [
    0b111011111000100, // L 	0
    0b111001011110011, // L 	1
    0b111110110101010, // L 	2
    0b111100010011101, // L 	3
    0b110011000101111, // L 	4
    0b110001100011000, // L 	5
    0b110110001000001, // L 	6
    0b110100101110110, // L 	7
    0b101010000010010, // M 	0
    0b101000100100101, // M 	1
    0b101111001111100, // M 	2
    0b101101101001011, // M 	3
    0b100010111111001, // M 	4
    0b100000011001110, // M 	5
    0b100111110010111, // M 	6
    0b100101010100000, // M 	7
    0b011010101011111, // Q 	0
    0b011000001101000, // Q 	1
    0b011111100110001, // Q 	2
    0b011101000000110, // Q 	3
    0b010010010110100, // Q 	4
    0b010000110000011, // Q 	5
    0b010111011011010, // Q 	6
    0b010101111101101, // Q 	7
    0b001011010001001, // H 	0
    0b001001110111110, // H 	1
    0b001110011100111, // H 	2
    0b001100111010000, // H 	3
    0b000011101100010, // H 	4
    0b000001001010101, // H 	5
    0b000110100001100, // H 	6
    0b000100000111011, // H 	7
];

#[cfg(test)]
mod tests {
    use pretty_assertions::assert_eq;
    use rstest::rstest;

    use super::*;

    #[rstest]
    #[case(0b111001_000100_010101, &[true, true, true, false, false, true, false, false, false, true, false, false, false, true, false, true, false, true])]
    #[case(0b000010_011110_100110, &[false, false, false, false, true, false, false, true, true, true, true, false, true, false, false, true, true, false])]
    fn test_to_18bit_array(#[case] input: u32, #[case] expected: &[bool]) {
        assert_eq!(to_bit_array(input, 18), expected);
    }
}
