//! Code 128:
//!
//! - Кодирует любые символы ASCII (цифры, буквы, специальные символы).
//! - Очень высокая плотность — помещается больше информации в меньшее пространство.
//! - Нет необходимости в регистрации — можно использовать произвольные данные.
//! - Поддерживается большинством сканеров.
//! - Широко используется в логистике, складской системе, упаковке.

mod characters;

use characters::{CHARS, Encoding, STOP, TERM};

/// # Общие принципы
///
/// 1. Кодирует символы ASCII:
///   - Поддерживает символы с кодами от 0 до 127 (все символы ASCII).
///   - Включает цифры, буквы, знаки препинания, управляющие символы (например, FNC1, FNC2 и др.).
///
/// 2. Три набора символов (A, B, C):
///   - `Code Set A` — символы с кодами 0–95 (A-Z, 0-9, специальные символы и FNC 1-4).
///   - `Code Set B` — ASCII символы с кодами 32–127 (A-Z, a-z, 0-9, специальные символы и FNC 1-4).
///   - `Code Set C` — используется для парных цифр (00–99). Позволяет компактно кодировать числа: две цифры кодируются одним символом.
///
/// 3. Переключение между наборами:
///   - Можно переключаться между наборами внутри одного штрих-кода с помощью специальных символов:
///       - `SHIFT` — однократное переключение на другой набор.
///       - `CODE A, CODE B, CODE C` — переключение на постоянной основе.
///
/// # Структура штрих-кода Code 128
///
/// 1. Стартовый символ:
///   - Определяет набор, с которого начинается кодирование (START A, START B, START C).
///   - Каждый стартовый символ имеет своё значение и влияет на интерпретацию следующих данных.
/// 2. Данные:
///   - Последовательность символов, закодированных в соответствии с текущим набором.
///   - Если используется Set C, числа группируются по 2 цифры.
/// 3. Контрольная сумма (Checksum):
///   - Вычисляется по специальному алгоритму, включает в себя все символы данных и стартовый символ.
///   - Обеспечивает проверку целостности данных при сканировании.
/// 4. Стоп-символ:
///   - Обозначает окончание штрих-кода.
///   - Одинаков для всех наборов.
///
/// # Особенности
///
/// - Каждый символ (включая стартовый, данные и контрольную сумму) представлен шаблоном штрихов и пробелов.
/// - Всего в символе 6 элементов (3 штриха и 3 пробела).
/// - Ширина элементов может быть 1, 2, 3 или 4 модуля.
/// - Общая ширина всех 6 элементов всегда равна 11 модулям.
struct Code128 {}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum CodeSet {
    A,
    B,
    C,
}

impl CodeSet {
    pub fn encode(self, pattern: &str) -> Option<Encoding> {
        let set_idx = self.index();

        CHARS.iter().find_map(|charset| {
            if charset.0[set_idx] == pattern {
                Some(charset.1)
            } else {
                None
            }
        })
    }

    fn index(self) -> usize {
        match self {
            CodeSet::A => 0,
            CodeSet::B => 1,
            CodeSet::C => 2,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_codeset_encode() {
        assert_eq!(
            CodeSet::A.encode("A"),
            Some([1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0])
        );
        assert_eq!(
            CodeSet::B.encode("A"),
            Some([1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0])
        );
        assert_eq!(
            CodeSet::C.encode("33"),
            Some([1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0])
        );
        assert_eq!(
            CodeSet::B.encode("*"),
            Some([1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0])
        );
        assert_eq!(
            CodeSet::C.encode("52"),
            Some([1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0])
        );
    }
}
